Slip 1
Q.1 Write a program that demonstrates the use of nice() system call. After a child process is started using fork(), assign higher priority to the child using nice() system call.                        [10 marks]
:-
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/resource.h>

int main() {
    pid_t child_pid;

    // Create a child process
    child_pid = fork();

    if (child_pid < 0) {
        perror("Fork failed");
        exit(1);
    } else if (child_pid == 0) {
        // This is the child process
        printf("Child process ID: %d\n", getpid());
        
        // Set a higher priority for the child process (lower nice value)
        if (nice(-10) == -1) {
            perror("Nice failed for the child process");
            exit(1);
        }
        
        // Display the new priority of the child process
        int new_nice_value = nice(0);
        printf("Child process priority (nice value) after modification: %d\n", new_nice_value);
    } else {
        // This is the parent process
        printf("Parent process ID: %d\n", getpid());
        
        // Wait for the child process to finish
        wait(NULL);
    }

    return 0;
}

Q.2 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n=3 as the number of memory frames.

Reference String :3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6

Implement FIFO     
:-
#include<stdio.h>

#define MAX_MEM_SIZE 50
#define MAX_REFERENCES 50


//shared variables
int no_of_frames, mem[MAX_MEM_SIZE], page_ref[MAX_REFERENCES], page_req_ptr=0, victim=-1, page_faults=0, page_replacements=0;




void print_memory()
{
	int i;
	printf("\nMEMORY: ");
	for(i=0; i<no_of_frames; i++)
	{
		printf(" | %d  ",mem[i]);
	}
	printf("	Current Page Req: %d | Total Page Faults: %d\n",page_ref[page_req_ptr],page_faults);
}

//allocate_frame() searches for first free frame to allocate
//returns 0 if Page replacement not required, i.e. free memory available
//else returns 1 if page replacement required, appropriate algorithm is chosen in main()
int allocate_frame()
{
	int i;
	//search in memory if page already exists; if exists return 0
	for(i=0; i<no_of_frames; i++)
	{
		if(mem[i] == page_ref[page_req_ptr])
		return 0;
	}
	//page not found in memory
	page_faults++;	
	
		
	//search for free memory
	for(i=0; i<no_of_frames; i++)
	{
		if(mem[i] == -1) break; //free frame available, stop searching
	}
	
	if(i >= no_of_frames) // free frame not found
	return 1; //page replacement needed
	
	
	//free frame allocation
	else if(i < no_of_frames) // free frame is i'th frame, allocate to page
	{
		mem[i] = page_ref[page_req_ptr];
		return 0;
	}	
	
	
}//end of allocate_frame()

void FIFO()
{
	victim++;
	if(victim >= no_of_frames) victim=0;
	mem[victim] = -1; // victim page swapped out
	printf("\nFIFO: Victim Frame Evacuated: ");
	print_memory();
}






 
main()
{
	int  i;	
	
	//accepting no of frames
	printf("\nDEMAND PAGING: FIFO SIMULATION\n");
	printf("\nEnter number of frames: ");
	scanf("%d",&no_of_frames);
	
	//initializing memory
	for(i=0; i<MAX_MEM_SIZE; i++)
	{
		mem[i] = -1;
		page_ref[i] = -1;
	}
	
	print_memory();
	
	//accept page reference string
	printf("\nPage references (HIT \"E\" after after your input): ");
	for(i=0; i<MAX_MEM_SIZE; i++)
	{
		scanf("%d",&page_ref[i]);
		if(page_ref[i] == 'e' || page_ref[i] == 'E')
		{
			page_ref[i] = -1;
			break;
		}
	}
	
	while(page_ref[page_req_ptr] != -1) // process all page requests
	{
		//allocate frame to next page
		//page_ref initialized to -1, to know end of references
		if(allocate_frame() == 0) //allocation successful
		{
			print_memory(); //print memory status: page scheduling
			page_req_ptr++;
		}
		
		//else if allocation not successful
		else
		{
			FIFO();
			page_faults--; 
			// since above call to allocate_frame() incremented faults
			// FIFO was called to free a frame
			// Again a call to actually allocate frame
			// (to prohibit re-increment of page_faults)  
			
			allocate_frame(); // this allocation is surely successful
			page_replacements++;
			print_memory(); //print memory status: page scheduling
			page_req_ptr++; // hence page_req_ptr incremented
		}		
		
		
		
	}//while(page_requests)
	
	printf("\nTotal Page Faults: %d\nTotal Page Replacements: %d\n",page_faults, page_replacements);
	
}
                                                                        OR
Q2.Write a C program to simulate Banker algorithm for the purpose of deadlock avoidance. Consider the following snapshot of system, A, B, C and D are the resource type.

a) Calculate and display the content of need matrix?
b) Is the system in safe state? If display the safe sequence.
c) If a request from process P arrives for (0, 4, 2, 0) can it be granted immediately by keeping the system in safe state. Print a message                                                                                
:-
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define MAX_PROCESSES 50

//here, Allocation[100][10] Types of resources = 10 Maximum boundary assumed.
//Maximum of 50 processes & 10 resources can be handles by the system.

int Allocation[100][10],Max[100][10],Need[100][10],Available[10],Total[10]={0,0,0};
int no_of_resources,no_of_processes;
static int finish[MAX_PROCESSES];

int finishAll()
{
	int i;
	for(i=0 ; i<no_of_processes ; i++)
		if(finish[i]==0) 
			return 0;
	return 1; 
}

int safe()
{
	int i,j,flag=1;
	int tAllocation[100][10],tNeed[100][10],tAval[10];
	
	//Copy available resources to temporary available resources
	for(i=0 ; i< no_of_resources ; i++)
		tAval[i]=Available[i];
		
	for(i=0 ; i< no_of_processes ; i++)
	{
		finish[i]=0; // all finish flags made false
		
		// Allocation and need are copied to temporary tables
		for(j=0; j<no_of_resources; j++)
		{
			tAllocation[i][j]=Allocation[i][j];
			tNeed[i][j]=Need[i][j];
		}
	}
	
	printf("\n\nSafe Sequence : ");
	
	//processing done on each process
	while(!finishAll())
	{
		flag=1;
		for(i=0;i<no_of_processes;i++)
		{
			if(finish[i]==1)
				continue;
			//if the process "i" has been "finished"
			//continue to next process	
			
			
			for(j=0;j<no_of_resources;j++)
				if(tNeed[i][j]>tAval[j])
				break;
			//if need > available: request cannot be fulfilled
				
			if(j==no_of_resources)// all needs are in availability range
			{
				finish[i]=1;   
				//make finish flag for i'th process true
				
				printf(" P%d",i); 
				// the process number is appended to safe sequence
				
				flag=0; 
				// flag : toggled to know if process is finished
				
				//changes are refleceted to temporary tables
				for(j=0;j<no_of_resources;j++)
				{
					tAval[j]-=tNeed[i][j];
					tAllocation[i][j]+=tNeed[i][j];
					tNeed[i][j]=0;
				}
				
				//When all required resources are with the process it will execute fully.
				//this indicates process is finished
				//deAllocation of resources
				for(j=0;j<no_of_resources;j++)
                                {
                                        tAval[j]+=tAllocation[i][j];
                                        tAllocation[i][j]=0;
                                }

			}
		}//Outer for loop ends. It runs for all processes.
		
		if(flag==1)return 0;
	}
  	return 1;
}



void request()
{
	int i,j,p,Req[10];
	
	printf("\n\nRequest from which Process ? ");
	scanf("%d",&i);
	//i'th process is requesting resources
	if(i>no_of_processes || i<0)
	{
		printf("\nError : Invalid Process ID, Process %d does not exist.",i);
		return;
	}
	
	printf("\nEnter Request : ");
	for(j=0;j<no_of_resources;j++)
		scanf("%d",&Req[j]);
		
	for(j=0;j<no_of_resources;j++)
		if(Req[j]>Need[i][j])
			break;
	
	// process cannot request more than need
	if(j<no_of_resources) printf("\nError : Invalid Request");
	
	//if valid request
	else
	{
		printf("\nRequest is Valid");
		for(j=0;j<no_of_resources;j++)
			if(Req[j] > Available[j])
				break;
		//If request is valid, but resources not available with system
		// process will have to wait
		
		if(j<no_of_resources)
		printf("\nWAIT : Not enough resources available with system.");
		
		//if request valid, and resources available
		else
		{
			printf("\nRequired resources are Available.");
			for(j=0;j<no_of_resources;j++)
			{
				Available[j]-=Req[j];
				Allocation[i][j]+=Req[j];
				Need[i][j]-=Req[j];
			}
			if(safe())
			printf("\nSystem will remain in safe state.\nRequest granted.");
			
			else
			{
				printf("\nSystem does not remain in safe state.");
				printf("\nRequest NOT granted.");
				
				//loading resources back
				for(j=0;j<no_of_resources;j++)
				{
					Available[j]+=Req[j];
        	                        Allocation[i][j]-=Req[j];
	                                Need[i][j]+=Req[j];

				}
			}
		}
	}

	
}

FindNeed()
{
	int i,j,resourceCount;
	char resource='A';

	printf("\nNeed Table\n------------------------");
	printf("\nProcess");
	for(resourceCount=1; resourceCount<= no_of_resources; resourceCount++)
	printf("\t%c ",resource++);
	
	for(i=0;i<no_of_processes;i++)
	{
		printf("\n\nP%d :   \t",i);
		for(j=0;j<no_of_resources;j++)
		{
			Need[i][j]=Max[i][j]-Allocation[i][j];
			printf("%d\t",Need[i][j]);
		}
	}
}

AcceptAllocationTable()
{
	int i,j,resourceCount;
	char resource='A';
	
	printf("\nEnter instances of Resources Allocated to each process : ");
	printf("\n\nAllocation\n-------------");
	printf("\nProcess");
	for(resourceCount=1; resourceCount<= no_of_resources; resourceCount++)
	printf("\t%c ",resource++);
	
	for(i=0;i<no_of_processes;i++)
	{
		printf("\nP%d :   \t",i);
		for(j=0;j<no_of_resources;j++)
		{
			scanf("%d",&Allocation[i][j]);
			Total[j]+=Allocation[i][j];
		}
	}
}

AcceptMaxTable()
{
	int i,j,resourceCount;
	char resource='A';

	printf("\n\nEnter Max Resource Requirements for each process : ");
        printf("\n\nMAX\n-------------");
        printf("\nProcess");
	for(resourceCount=1; resourceCount<= no_of_resources; resourceCount++)
	printf("\t%c ",resource++);
        
        for(i=0;i<no_of_processes;i++)
        {
                printf("\nP%d :   \t",i);
                for(j=0;j<no_of_resources;j++)
                {
                        scanf("%d",&Max[i][j]);
                       
                }
        }

}

main()
{
	int i,j,choice=1,resourceCount;
	char resource='A';

	
	printf("\nHow many types of resources ? ");
	scanf("%d",&no_of_resources);
	
	printf("\nHow many Processes ? ");
	scanf("%d",&no_of_processes);
		
	AcceptAllocationTable();
	
	printf("\nEnter Available resources with system : ");
	
		printf("\n\nAVAILABLE\n-------------");
        	printf("\nResType");
		for(resourceCount=1; resourceCount<= no_of_resources; resourceCount++)
		printf("\t%c ",resource++);
		printf("\n\t  ");
	
	for(j=0;j<no_of_resources;j++)
	{
		scanf("%d",&Available[j]);
		Total[j]+=Available[j];
	}
	
	resource='A'; // to print Total: again set to A
	
	printf("\nTotal system Resources are : ");
	printf("\n\nTOTAL\n-------------\n");
        	printf("\nTotal  ");
		for(resourceCount=1; resourceCount<= no_of_resources; resourceCount++)
		printf("\t%c ",resource++);
		printf("\n");
	for(j=0;j<no_of_resources;j++)
		printf("\t%d",Total[j]);
		
	AcceptMaxTable();
	
	FindNeed();
	
	if(safe())
	{
		printf("\n\nStatus : System is in Safe state");
		do
		{
			request();
			printf("\n\nAny more request ? (yes=1/no=0): ");
			scanf("%d",&choice);
		}while(choice == 1);
	}
	
	else
	
		printf("\nStatus : System is NOT in safe state");
		//System is unsafe
		
}

Slip 2
Q.1 Create a child process using fork(), display parent and child process id. Child process will display the message “Hello World” and the parent process should display “Hi”.
:-
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t child_pid;

    // Create a child process
    child_pid = fork();

    if (child_pid < 0) {
        perror("Fork failed");
        exit(1);
    } else if (child_pid == 0) {
        // This is the child process
        printf("Child process ID: %d\n", getpid());
        printf("Hello World\n");
    } else {
        // This is the parent process
        printf("Parent process ID: %d\n", getpid());
        printf("Hi\n");
    }

    return 0;
}

Q.2 Write  the  simulation  program  using SJF (non-preemptive).  The  arrival  time  and  first  CPU bursts of different jobs should be input to the system. Assume the fixed I/O waiting time (2 units). The next CPU burst should be generated using random function. The output should give the Gantt chart,   Turnaround   Time   and   Waiting   time   for   each    process    and    average    times.
:-
#include<stdio.h>
 int main()
{
    int bt[20],p[20],wt[20],tat[20],i,j,n,total=0,pos,temp;
    float avg_wt,avg_tat;
    printf("Enter number of process:");
    scanf("%d",&n);
  
    printf("\nEnter Burst Time:");
    for(i=0;i<n;i++)
    {
        printf("p%d:",i+1);
        scanf("%d",&bt[i]);
        p[i]=i+1;         
    }
  
   //sorting of burst times
    for(i=0;i<n;i++)
    {
        pos=i;
        for(j=i+1;j<n;j++)
        {
            if(bt[j]<bt[pos])
                pos=j;
        }
  
        temp=bt[i];
        bt[i]=bt[pos];
        bt[pos]=temp;
  
        temp=p[i];
        p[i]=p[pos];
        p[pos]=temp;
    }
   
    wt[0]=0;            
  
   
    for(i=1;i<n;i++)
    {
        wt[i]=0;
        for(j=0;j<i;j++)
            wt[i]+=bt[j];
  
        total+=wt[i];
    }
  
    avg_wt=(float)total/n;      
    total=0;
  
    printf("\nProcess\t    Burst Time    \tWaiting Time  \tTurnaround Time");
    for(i=0;i<n;i++)
    {
        tat[i]=bt[i]+wt[i];   
        total+=tat[i];
        printf("\np%d\t\t  %d\t\t    %d\t\t\t%d",p[i],bt[i],wt[i],tat[i]);
    }
  
    avg_tat=(float)total/n;    
    printf("\n\nAverage Waiting Time=%f",avg_wt);
    printf("\nAverage Turnaround Time=%f\n",avg_tat);
}
                                                                               OR
Q2.Partially implement the Menu driven Banker's algorithm for accepting Allocation, Max from user.

a) Accept Available
b) Display Allocation, Max c) Find Need and display It,
d) Display Available Consider the system with 3 resources types A,B, and C with 7,2,6 instances respectively.

Consider the following snapshot:

Answer the following questions:
a) Display the contents of Available array?
b) Is there any deadlock? Print the message    
:-
#include<stdio.h>
int A[10][10],M[10][10],N[10][10],Av[10],Safe[10],Finish[10],nor,nop;
void AcceptData(int X[][10])
{
	int i,j;
	for(i=0;i<nop;i++)
	{
		printf("P%d\n",i);
		for(j=0;j<nor;j++)
		{
			printf("%c: ",65+j);
			scanf("%d",&X[i][j]);
		}
	}
}
void AcceptAvailability()
{
	int i;
	for(i=0;i<nor;i++)
	{
		printf("%c: ",65+i);
		scanf("%d",&Av[i]);
	}
}
void DisplayData()
{
	int i,j;
	printf("\n\tAllocation\t\tMax\t\tNeed\n");
	printf("\t");
	for(i=0;i<3;i++)
	{
		for(j=0;j<nor;j++)
			printf("%4c",65+j);
		printf("\t");
	}
	for(i=0;i<nop;i++)
	{
		printf("\nP%d\t",i);
		for(j=0;j<nor;j++)
			 printf("%4d",A[i][j]);
		printf("\t");
		for(j=0;j<nor;j++)
			printf("%4d",M[i][j]);
		printf("\t");
		for(j=0;j<nor;j++)
		printf("%4d",N[i][j]);
	}
	printf("\nAvailable\n");
	for(j=0;j<nor;j++)
		printf("%4d",Av[j]);
}
void CalcNeed()
{
	int i,j;
	for(i=0;i<nop;i++)
		for(j=0;j<nor;j++)
			N[i][j] = M[i][j] - A[i][j];
}
int checkNeed(int pno)
{
	int i;
	for(i=0;i<nor;i++)
		if(N[pno][i] > Av[i])
			return(0);
	return(1);
}
void Banker()
{
	int i=0,j=0,k=0,flag=0;
	while(flag<2)
	{
		if(!Finish[i])
		{
			printf("\nNeed%d(",i);
			for(j=0;j<nor;j++)
				printf("%d,",N[i][j]);
			if(!checkNeed(i))
			{
				printf("\b)>Available(");
				for(j=0;j<nor;j++)
					printf("%d,",Av[j]);
				printf("\b)");
				printf("\nNeed Cannot be satisfied, consider next process");
			}
			else
			{
				printf("\b)<=Available(");
				for(j=0;j<nor;j++)
					printf("%d,",Av[j]);
				printf("\b)");
				printf("\nNeed can be satisfied, so allocate required resources");
				printf("\nAllocation%d\t\tAvailable\t\tNeed%d\n",i,i);
				for(j=0;j<nor;j++)
				{
					A[i][j] = M[i][j];
					Av[j] -= N[i][j];
					N[i][j] = 0;
				}
				for(j=0;j<nor;j++)
					printf("%6d",A[i][j]);
				printf("\t");
				for(j=0;j<nor;j++)
					printf("%6d",Av[j]);
				printf("\t");
				for(j=0;j<nor;j++)
					printf("%6d",N[i][j]);
				printf("\nAfter P%d terminates it will release all its resources",i);
				printf("\nAllocation%d\t\tAvailable\t\tNeed%d\n",i,i);
				for(j=0;j<nor;j++)
				{
					Av[j] += A[i][j];
					A[i][j] = 0;
				}
				for(j=0;j<nor;j++)
					printf("%6d",A[i][j]);
				printf("\t");
				for(j=0;j<nor;j++)
					printf("%6d",Av[j]);
				printf("\t");
				for(j=0;j<nor;j++)
					printf("%6d",N[i][j]);
				Safe[k++] = i;
				Finish[i]=1;
			}
		}
		if((i+1)%nop == 0)
			flag++;
		i=(i+1)%nop;
	}
	if(k==nop)
	{
		printf("\nSystem is in safe state...");
		printf("\nSafe Sequence: ");
		for(i=0;i<k;i++)
			printf("P%d->",Safe[i]);
        printf("\b)");
	}
	else
	{
		printf("\nSystem is in not safe state...");
	}
}

void main()
{
	printf("\nEnter No.of Processes & No.of Resources: ");
	scanf("%d %d",&nop,&nor);
	printf("Enter Allocation\n");
	AcceptData(A);
	printf("Enter Max Requirement\n");
	AcceptData(M);
	printf("Enter Availability\n");
	AcceptAvailability();
	CalcNeed();
	DisplayData();
	Banker();
}

Slip 3
Q. 1 Creating a child process using the command exec(). Note down process ids of the parent and the child processes, check whether the control is given back to the parent after the child process terminates.                                                                                               [10 marks]
:-
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    pid_t child_pid;

    // Create a child process
    child_pid = fork();

    if (child_pid < 0) {
        perror("Fork failed");
        exit(1);
    } else if (child_pid == 0) {
        // This is the child process
        printf("Child process ID: %d\n", getpid());

        // Execute a different program in the child process using exec
        char *args[] = {"/bin/ls", "-l", NULL}; // Replace with the desired program
        if (execvp(args[0], args) == -1) {
            perror("Exec failed");
            exit(1);
        }
    } else {
        // This is the parent process
        printf("Parent process ID: %d\n", getpid());

        // Wait for the child process to terminate
        int status;
        wait(&status);

        if (WIFEXITED(status)) {
            printf("Child process terminated with status: %d\n", WEXITSTATUS(status));
        }
    }

    printf("Control is back to the parent process.\n");

    return 0;
}
Q.2 Write the simulation program using FCFS. The arrival time and first CPU bursts of different jobs should be input to the system. Assume the fixed I/O waiting time (2 units). The next CPU burst should be generated using random function. The output should  give the Gantt  chart,Turnaround Time    and    Waiting    time     for     each     process     and     average     times. [20 marks]
:-


Slip 4
Q.1 Write a program to illustrate the concept of orphan process ( Using fork() and sleep())
:-
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t child_pid;

    // Create a child process
    child_pid = fork();

    if (child_pid < 0) {
        perror("Fork failed");
        exit(1);
    } else if (child_pid == 0) {
        // This is the child process
        printf("Child process ID: %d\n", getpid());

        // Sleep for a while to keep the child process running
        sleep(5);
        printf("Child process done.\n");
    } else {
        // This is the parent process
        printf("Parent process ID: %d\n", getpid());

        printf("Parent process sleeping for a while...\n");
        sleep(2);

        printf("Parent process done.\n");
    }

    return 0;
}

Q.2 Write the program to simulate Non-preemptive Priority scheduling. The arrival time and first CPU burst and priority for different n number of processes should be input to the algorithm. Assume the fixed IO waiting time (2 units). The next CPU-burst should be generated randomly. The output should give Gantt chart, turnaround time and waiting time for each process. Also find the average waiting time and turnaround time..                                                              
:-
 
                                                                             OR
Q.2 Write a C program to simulate Banker algorithm for the purpose of deadlock avoidance. Consider the following snapshot of system, A, B, C and D are the resource type.
a) Calculate and display the content of need matrix?
b) Is the system in safe state? If display the safe sequence.
c) If a request from process P arrives for (0, 4, 2, 0) can it be granted immediately by keeping the system in safe state. Print a message                                                                                
 :-
IN Slip 1 Q2. Banker Algorithm      

Slip 5
Q.1 Write a program that demonstrates the use of nice () system call. After a child process is started using fork (), assign higher priority to the child using nice () system call.          [10 marks]
:-
IN Slip 1 Q1 

Q.2 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames. Reference String: 3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6
i. Implement FIFO    
:-
IN Slip 1 Q2
                                                                           OR
Q.2 partially implement the Menu driven Banker's algorithm for accepting Allocation, Max from user.
a) Accept Available
b) Display Allocation, Max c) Find Need and display It,
d) Display Available Consider the system with 3 resources types A,B, and C with 7,2,6 instances respectively.

Consider the following snapshot:
Answer the following questions:
a) Display the contents of Available array?
b) Is there any deadlock? Print the message                                                                     
:-
IN Slip 2 Q2


Slip 6
Q.1 Write a program to find the execution time taken for execution of a given set of instructions
(use clock() function)                                                                                                
:-
#include <stdio.h>
#include <time.h>

int main() {
    clock_t start_time, end_time;
    double execution_time;

    // Record the start time
    start_time = clock();

    // Your set of instructions to measure execution time
    for (int i = 0; i < 1000000; i++) {
        // Some work to measure execution time
    }

    // Record the end time
    end_time = clock();

    // Calculate the execution time in seconds
    execution_time = (double)(end_time - start_time) / CLOCKS_PER_SEC;

    printf("Execution time: %f seconds\n", execution_time);

    return 0;
}

Q.2 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String :3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6
Implement FIFO 
:-
IN Slip 1 Q2

Slip 7 
Q.1 Write a program to create a child process using fork().The parent should goto sleep state and child process should begin its execution. In the child process, use execl() to execute the “ls” command.                                                                                                                        [10 marks]
:-
IN Slip 2 Q1

Q.2 Write the simulation program using FCFS. The arrival time and first CPU bursts of different jobs should be input to the system. Assume the fixed I/O waiting time (2 units). The next CPU burst should be generated using random function. The output should give the Gantt chart, Turnaround Time and Waiting time for each process and average times         
:-

                                                                              OR
Q.2 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
i. Implement LRU  
:-    
#include<stdio.h>
	int page[20];	
	int frame[20];
	int n , p;		// no. of frames , no. of pages
	int i , j , x , already_present , page_fault=0 , current_frame;
	int victim_list[20][2];		// [page] , [most_recent_position]
 
	 void  initializeFrames()
	  {
	  	for(j=0 ; j<20 ; j++)
		 {
		 	frame[j] = -1;
		 }
	  }
 
	 int search()
	  {
	  	already_present = 0;
		for(j=0 ; j<n ; j++)
		 {
		 	if(frame[j] == page[i])
			 {
			 	already_present = 1;
				break;
			 }
		 }
	 
		return (already_present); 
	  }

	 void disp()
	  {
	  	if(already_present == 0)
			printf("\n ?? Page Request : %2d \t", page[i]);
		else
		 	printf("\n    Page Request : %2d \t", page[i]);
		
		for(j=0;j<n;j++)
		 {
		 	if(frame[j] == -1)
				printf(" |      *** \t");
			else
				printf(" |      %2d \t",frame[j]);	
				
		 }
		printf("\n-------------------------------------------------------------------");
	  }
	 
	 int LRU()
	  {
	  		  
		int t , max = 0 , index = -1;
		
		for(j=0; j<n; j++)
		 {
			victim_list[j][0] = frame[j];
		 }
		
		for(j=0;j<n;j++)	// currently allocated frames
		 {
		 	for(t=0; t<i; t++)	// 'i' is no. of page requests till now
			 {
				if(page[t] == victim_list[j][0])
			{	
					victim_list[j][1] = t;	// t is its last pos.
				}
			 }
		 }
		
		  
		 // Now , out of these , page with largest distance from the current pos. is the victim
		 for(j=0;j<n;j++)
		  {
		  	if((i - victim_list[j][1]) > max)
			 {
			 	max = i - victim_list[j][1];
				index = j;
			 }
		  }
		  
		 return index; 
	  }
	 
	 
	 main()
	  {
		system("clear");
		
		initializeFrames();
		
		printf("\n How many frames ? : ");
		scanf("%d",&n);
		
		printf("\n How many pages ? : ");
		scanf("%d",&p);
		printf("\n Enter the one by one : ");
		for(i=0; i<p; i++)
		 {
		 	printf("\n Page[%d]  :  ",i+1);
			scanf("%d",&page[i]);
		 }
		 
		printf("\n\n Frames  \t -->   ");
		for(i=0 ; i<n ; i++)
		 	printf("  |      %2d     ",i+1);
		
		printf("\n---------------------------------------------------------------------");
	
			/*  First n frames in FIFO manner */
		x = 0;
		for(i=0 ; i<p ; i++)
			 {
			if(search() == 1)
		 {		 	// OK , already present
			 }
			else
			 {
				page_fault++;
				current_frame = x++;
				frame[current_frame] = page[i];
					
				if(x>n)
				 {
				 	 page_fault-- ;
					 break;
				 }
			 }
			
			disp();
		 }
		 
		 	/* Actual LRU */
		 for(; i<p; i++)
		  {
		  	if(search() == 1)
			 {		//OK , already present
			 }
			else
			 {
				page_fault++;
				current_frame = LRU();
				frame[current_frame] = page[i];
			 }
			 
			disp();   
		  }
		 
		 printf("\n\n\t Total no. of Page Faults : %d \t\t(?? = Page Fault)\n\n",page_fault);
	}
	 
Slip 8
Q.1 Write a C program to accept the number of process and resources and find the need matrix content and display it.                                                                                                      
:-
#include <stdio.h>

#define MAX_RESOURCES 10
#define MAX_PROCESSES 10

int available[MAX_RESOURCES];
int maximum[MAX_PROCESSES][MAX_RESOURCES];
int allocation[MAX_PROCESSES][MAX_RESOURCES];
int need[MAX_PROCESSES][MAX_RESOURCES];

int main() {
    int num_processes, num_resources;

    printf("Enter the number of processes: ");
    scanf("%d", &num_processes);

    printf("Enter the number of resource types: ");
    scanf("%d", &num_resources);

    // Input the available resources
    printf("Enter the available resources for each type:\n");
    for (int i = 0; i < num_resources; i++) {
        scanf("%d", &available[i]);
    }

    // Input the maximum resources required by each process
    printf("Enter the maximum resources required for each process:\n");
    for (int i = 0; i < num_processes; i++) {
        for (int j = 0; j < num_resources; j++) {
            scanf("%d", &maximum[i][j]);
        }
    }

    // Input the resources currently allocated to each process
    printf("Enter the resources currently allocated to each process:\n");
    for (int i = 0; i < num_processes; i++) {
        for (int j = 0; j < num_resources; j++) {
            scanf("%d", &allocation[i][j]);
        }
    }

    // Calculate the Need Matrix
    for (int i = 0; i < num_processes; i++) {
        for (int j = 0; j < num_resources; j++) {
            need[i][j] = maximum[i][j] - allocation[i][j];
        }
    }

    // Display the Need Matrix
    printf("\nNeed Matrix:\n");
    for (int i = 0; i < num_processes; i++) {
        for (int j = 0; j < num_resources; j++) {
            printf("%d ", need[i][j]);
        }
        printf("\n");
    }
return 0;
}

Q.2. Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n =3 as the number of memory frames.
Reference String : 12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8
Implement OPT         
:-      
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n, page_faults = 0;
    printf("Enter the number of memory frames: ");
    scanf("%d", &n);

    int* memory = (int*)malloc(n * sizeof(int));
    int* reference_string = (int*)malloc(n * sizeof(int));

    printf("Enter the page reference string (comma-separated): ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &reference_string[i]);
    }

    for (int i = 0; i < n; i++) {
        int page = reference_string[i];

        // Check if the page is already in memory
        int page_in_memory = 0;
        for (int j = 0; j < n; j++) {
            if (memory[j] == page) {
                page_in_memory = 1;
                break;
            }
        }

        if (!page_in_memory) {
            // If there is a free frame, use it
            int free_frame = -1;
            for (int j = 0; j < n; j++) {
                if (memory[j] == -1) {
                    free_frame = j;
                    break;
                }
            }

            // If no free frame, replace a page using the OPT algorithm
            if (free_frame == -1) {
                int farthest_occurrence = -1;
                int page_to_replace = -1;
                for (int j = 0; j < n; j++) {
                    int page_found = 0;
                    for (int k = i + 1; k < n; k++) {
                        if (memory[j] == reference_string[k]) {
                            if (k > farthest_occurrence) {
                                farthest_occurrence = k;
                                page_to_replace = j;
                            }
                            page_found = 1;
                            break;
                        }
                    }
                    if (!page_found) {
                        page_to_replace = j;
                        break;
                    }
                }

                memory[page_to_replace] = page;
                page_faults++;
            } else {
                memory[free_frame] = page;
            }
        }
    }

    printf("Total number of page faults: %d\n", page_faults);

    free(memory);
    free(reference_string);

    return 0;
}
                                                                                                                                                                                                                                                                                                        
  Slip 9
Q.1 Write a program to create a child process using fork().The parent should goto sleep state and child process should begin its execution. In the child process, use execl() to execute the “ls” command.                                                                                                                         [10 marks]
:-
IN Slip 2 Q1

Q.2 Partially implement the Menu driven Banker's algorithm for accepting Allocation, Max from user.
a) Accept Available
b) Display Allocation, Max c) Find Need and display It,
d) Display Available Consider the system with 3 resources types A,B, and C with 7,2,6 instances respectively.
Consider the following snapshot:
:-
IN Slip  2 Q2

Slip 10
Q.1 Write a program to illustrate the concept of orphan process (Using fork() and sleep())
:-
IN Slip 4 Q1

Q.2 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n=3 as the number of memory frames.
Reference String : 12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8
Implement OPT 
:-
IN Slip 8 Q2

Slip 11
Q.1 Create a child process using fork(), display parent and child process id. Child process will display the message “Hello World” and the parent process should display “Hi”.
:-
IN Slip 2 Q 1

Q.2 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String: 0, 2, 1, 6, 4, 0, 1, 0, 3, 1, 2, 1
Implement FIFO     
:-       
IN Slip 1 Q 2

Slip 12

Q.1  Write a program to illustrate the concept of orphan process ( Using fork() and sleep()) .                                                                                                               
:-
IN Slip 4 Q 1

Q.2 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String : 12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8
Implement OPT                                                                                                                                                                                                               
:-
IN Slip 8 Q2
 
Slip 13
Q.1 Write a program that demonstrates the use of nice() system call. After a child process is started using fork(), assign higher priority to the child using nice() system call.           [10 marks]
:-IN Slip 1 Q 1

Q.2 Write a C program to simulate Banker algorithm for the purpose of deadlock
avoidance.  Consider the following snapshot of system, A, B, C and D are the resource type.
a) Calculate and display the content of need matrix?
b) Is the system in safe state? If display the safe sequence.
c) If a request from process P arrives for (0, 4, 2, 0) can it be granted immediately by keeping the system in safe state. Print a message
:-
IN Slip 1 Q2

Slip 14
Q.1 Write a program to find the execution time taken for execution of a given set of instructions
(use clock() function)                                                                                                    
:-
IN Slip 6 Q1

Q.2 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n =3 as the number of memory frames.
Reference String : 0, 2, 1, 6, 4, 0, 1, 0, 3, 1, 2, 1
Implement FIFO    
:-
IN Slip 1 Q2

Slip 15
Q.1 Write a program to create a child process using fork().The parent should goto sleep state and child process should begin its execution. In the child process, use execl() to execute the “ls” command.
:-
IN Slip 2 Q 1

Q.2 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String :7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
Implement LRU
:-
IN Slip 7 Q2     

Slip 16
Q.1 Write a program to find the execution time taken for execution of a given set of instructions
(use  clock() function)                                                                                                                    
:-
IN Slip 6 Q1

Q.2 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n =3 as the number of memory frames.
Reference String : 12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8
Implement OPT     
:-
IN Slip 8 Q2

Slip 17
Q.1 Write the program to calculate minimum number of resources needed to avoid deadlock.                                                                                                            
:-
#include <stdio.h>
#include <stdbool.h>

#define MAX_PROCESSES 5
#define MAX_RESOURCES 3

int available[MAX_RESOURCES];
int maximum[MAX_PROCESSES][MAX_RESOURCES];
int allocation[MAX_PROCESSES][MAX_RESOURCES];
int need[MAX_PROCESSES][MAX_RESOURCES];

bool isSafeState(int process, int request[]) {
    int work[MAX_RESOURCES];
    int finish[MAX_PROCESSES];

    // Initialize work and finish arrays
    for (int i = 0; i < MAX_RESOURCES; i++) {
        work[i] = available[i];
    }
    for (int i = 0; i < MAX_PROCESSES; i++) {
        finish[i] = false;
    }

    // Check if the requested resources are available
    for (int i = 0; i < MAX_RESOURCES; i++) {
        if (request[i] > need[process][i] || request[i] > work[i]) {
            return false;  // Request cannot be granted
        }
    }

    // Simulate resource allocation and release
    for (int i = 0; i < MAX_RESOURCES; i++) {
        work[i] -= request[i];
        allocation[process][i] += request[i];
        need[process][i] -= request[i];
    }

}

Q.2 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n=3 as the number of memory frames.
Reference String : 12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8
Implement OPT 
 :-
IN Slip 8 Q2

Slip 18
Q. 1  Write a C program to accept the number of process and resources and find the need matrix content  and display it.                                                                                     
:-
IN Slip 8 Q1

Q.2 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String : 12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8
Implement OPT
:-
IN Slip 8 Q2

Slip 19
Q.1 Write a program to create a child process using fork().The parent should goto sleep state and child  process  should  begin  its  execution.  In  the  child  process,  use  execl()  to  execute  the  “ls” command.                                                                                                                         [10 marks]
:-
IN Slip 2Q 1

Q.2Write the program to simulate Non-preemptive Priority scheduling. The arrival time and first CPU burst and priority for different n number of processes should be input to the algorithm. Assume the fixed IO waiting time (2 units). The next CPU-burst should be generated randomly. The output should give Gantt chart, turnaround time and waiting time for each process. Also find the average waiting time and turnaround time                                                                                                   
:-
                                                                                    OR
Q.2 Write a C program to simulate Banker algorithm for the purpose of deadlock
avoidance.  Consider the following snapshot of system, A, B, C and D are the resource type.
a) Calculate and display the content of need matrix?
b) Is the system in safe state? If display the safe sequence.
c) If a request from process P arrives for (0, 4, 2, 0) can it be granted immediately by keeping the system in safe state. Print a message
:-      

Slip 20 
Q.1 Write a program to create a child process using fork().The parent should goto sleep state and child process should begin its execution. In the child process, use execl() to execute the “ls” command.                                                                                                               [10 marks]
:-
IN Slip 9 Q1

Q.2 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n=3 as the number of memory frames.
Reference String : 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
i. Implement LRU                                                                                                                                                                                                                    
:-
IN Slip 7 Q2

                                                                                                                                                                                       